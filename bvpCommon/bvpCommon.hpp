/*
 * bvpCommon.hpp
 *
 *  Created on: Aug 20, 2020
 *      Author: bear
 */

#ifndef BVPCOMMON_HPP_
#define BVPCOMMON_HPP_

#include "debug.hpp"
#include <cstdint>

namespace BVP {

static const uint8_t BVP_STM32_i2c_address  = 0x3D; ///< Адрес I2C для STM32
static const uint8_t DATA_LEN = 32;  ///< Количество байт данных в пакете.

/** Пакет для общения STM32 и Raspberry на плате БВП61850.
 *
 *  При приеме пакета от STM32 периодически в первом байте старший бит
 *  принимается 1, вместо 0. Для обхода данной проблемы был добавлен байт
 *  начала пакета.
 *
 *  \todo Периодически на ПК принимается пакет "D5 FF FF ... FF".
 *  Похоже STM32 не получает ACK при передаче байт. Но откуда берется D5?
 */
class BvpPkg {
  static const uint8_t c_sop;           ///< Значение байта "Начало пакета".

  /** Структура пакета.
   *
   *  - Начало пакета: 0xAB
   *  - Номер последовательности: 1 .. 65535
   *    После передачи пакета принятый в ответ пакет должен содержать то же
   *    самое значение номера последовательности. Это считается подтверждением
   *    корректно принятого сообщения на приемной стороне. После этого номер
   *    увеличивается.
   *  - Данные
   *  - Контрольная сумма
   */
  struct __attribute__((packed)) pkg_t {
    uint8_t   sop = 0;                ///< Начало пакета.
    uint16_t  sequence = 0;           ///< Номер последовательности.
    uint8_t   data[DATA_LEN] = {0};  ///< Данные.
    uint8_t   checksum = 0;           ///< Контрольная сумма.
  };

public:
  /// Режим работы интерфейса I2C
  enum mode_t {
    MODE_slave = 0, ///< Ведомый.
    MODE_master     ///< Ведущий.
  };

  /// Конструктор
  explicit BvpPkg(mode_t mode);

  /** Подготовка пакета для передачи.
   *
   *  Если количество данных для передачи меньше размера данных в пакете
   *  то оставшиеся байты заполняются нулями.
   *  Если количество данных дял передачи превышает размер данных в пакете
   *  то новый пакет не формируется.
   *
   *  @param[in] data Данные.
   *  @param[in] len Количество байт данных.
   *  @return Результат подготовки (true если пакет готов к передаче).
   */
  bool addDataToPkg(uint8_t data[], uint16_t len);

  /** Получает данные из принятого пакета.
   *
   *  @param[out] data Данные.
   *  @param[in/out] Количество извлекаемых данных.
   *  @return Результат получения (true если данные получены).
   */
  bool getDataFromPkg(uint8_t data[], uint16_t &len) const;

  /** Возвращает указатель на начало буфера приема и его размер.
   *
   *  @param[out] size Размер буфера.
   *  @return Буфер.
   */
  uint8_t* getRxPkg(uint16_t &size) const;

  /** Возвращает указатель на начало буфера передачи и его размер.
   *
   *  @param[out] size Размер буфера.
   *  @return Буфер.
   */
  uint8_t* getTxPkg(uint16_t &size) const;

private:
  const mode_t mode;  ///< Режим работы интерфейса.
  pkg_t pkgRx;        ///< Пакет для приема.
  pkg_t pkgTx;        ///< Пакет для передачи.

  /** Вычисляет 8-битную контрольную сумму для массива 8-битных данных.
   *
   *  Алгоритм подсчета используемый в Авант:
   *    младший байт суммы всех байт данных.
   *
   *  @param[in] buf Массив 8-битных данных.
   *  @param[in] len  Количество данных.
   *  @return 8-битная контрольная сумма.
   */
  uint8_t calcChecksumAvant(const uint8_t buf[], uint16_t len) const;

  /** Вычисляет 8-битную контрольную сумму для массива 8-битных данных.
   *
   *  Алгоритм подсчета дополнение до 0:
   *    сумма всех байт с учетом контрольной суммы должна равняться 0.
   *
   *  @param[in] buf Массив 8-битных данных.
   *  @param[in] len  Количество данных.
   *  @return 8-битная контрольная сумма.
   */
  uint8_t calcChecksumCompl0(const uint8_t buf[], uint16_t len) const;

  /** Вычисляет 8-битную контрольную сумму для массива 8-битных данных.
   *
   *  Алгоритм подсчета взят из статьи https://habr.com/ru/post/278171/.
   *
   *  Добавлено начальное состояние 0xABBA, иначе для последовательности нулей
   *  была корректная контрольная сумма.
   *
   *  @param[in] buf Массив 8-битных данных.
   *  @param[in] len  Количество данных.
   *  @return 8-битная контрольная сумма.
   */
  uint8_t calcChecksumHabr(const uint8_t buf[], uint16_t len) const;

  /** Проверяет принятые данные.
   *
   *  @return Результат проверки принятого пакета (true - все в порядке).
   */
  bool checkRx() const;

  /** Вычисляет контрольную сумму для пакета.
   *
   *  @param[in] pkg Пакет.
   *  @return Контрольная сумма.
   */
  uint8_t getChecksum(const pkg_t &pkg) const;

  /** Проверяет контрольную сумму пакета.
   *
   *  @param[in] pkg Пакет.
   *  @return true если верная контрольная сумма, иначе false.
   */
  bool isChecksum(const pkg_t &pkg) const;

  /** Изменяет счетчик последовательности.
   *
   *  Увеличивает счетчик последовательности на 1.
   *  Если счетчик переполнен и значение устанавливается в 0, оно изменяется
   *  на 1.
   *
   *  @param[in] sequence Текущее значение счетчика последовательности.
   *  @return Новое значение счетчика последовательности (1 .. 65535).
   */
  uint16_t sequenceModify(uint16_t sequence) const;

  /** Проверяет номер последовательности для принятого пакета.
   *
   *  В режиме "Ведущий" номер принятой последовательности должен совпасть
   *  с номером переданной.
   *  В режиме "Ведомый" номер последовательности не проверяется.
   *
   *  @param[in] sequence Принятое значение счетчика последовательности.
   *  @return Результат проверки (true если верный номер).
   */
  bool sequenceRxCheck(uint16_t sequence) const;

  /** Возвращает номер последовательности для передаваемого пакета.
   *
   *  В режиме "Ведущий" номер последовательности должен увеличиться.
   *  В режиме "Ведомый" номер последовательнсти в передаваемом пакете
   *  должен быть равным принятому.
   *
   *  @return Номер последовательности.
   */
  uint16_t sequenceTxGet() const;

#ifdef TEST_FRIENDS
  TEST_FRIENDS;
#endif
};

} /* namespace BVP */

#endif /* BVPCOMMON_HPP_ */
